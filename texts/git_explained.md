# Git Explained## IntroductionMany challenges that we face as a society today, whether in business or private, is solved by software. In fact, many of us make a living out of it - by challenging the traditional approach and writing programs that can do it quicker and better. IT industry has been around for decades now, and it is said to be one of the basic canons of the economy of tomorrow. With world becoming ever more connected and more competitive it's vital for us to be as productive in our work as possible. The days when you were able to write the entire system in your basement and sell it to the world are over. Nowadays software is a team effort - you have to collaborate with other people, often distributed across the globe. The question is, how can we do it effectively?In this tutorial we will answer this very question. We will walk you through the tools that enable you and your team to work collectively on the same codebase, and explain its ins and outs. The goal is to make you a power user of Git. It  is one of the most popular version control system today and it is used by dev teams around the world.In this series we will take a non-traditional approach. We believe that you can truly understand this tool once you understood its internal mechanics. We will start with the big picture - the why and how. Next we will shift our attention to Git internals where we will explain what is going on under the hood. Finally, we will examine various scenarios and explain what Git is really doing. This way you can invest your time on solving real problems and not figuring out how you should be using a tool that is supposed to be a second nature to every developer. Many other tutorials take a rather easier approach when they explain Git using anecdotes and best practices. We believe this is a very dangerous approach in the long run. The minute something goes out of your playbook you are in trouble. You are more likely to make a mistake and fixing it will take you way more time than it should. On the other hand, if you know what you are doing you almost always make a well informed decision and avoid mistakes. ## The big picture In this section we will briefly explain what a version control system is, and what problems it is designed to solve. Next we will see how these objectives can be met by examining few most common workflows. Every team and project is different and how teams incorporate version control system into their workflow is their individual decision. We will cap this section with a quick overview of Git and what distinguishes Git from other version control systems.###What's version control system? Version control system can be understood quite literally. It's a database system that records versions of your files. It's a system that allows you to take snapshots of your code and save it to the database. Later you can explore this history and do all sorts of useful things with it. ###Why teams use VCS?**Collaboration** For a second let's consider how team of developers could work on the same codebase. They would probably have to use some shared folder for their code and constantly talk to one another who's working on which files in order to avoid overwriting someone else's changes. This approach is very time consuming and error-prone. VCS puts a workflow in place which allows multiple people working at the same time on shared codebase and reconciles any conflicts in a very scrutinized way.**Audit** Because software nowadays is team effort it is very important that the evolution of the code can be easily explained - who did this change, when and why. Auditing is at the core of VCS - it literally records versions of your files. Each new version of a file is labeled with a description, its author and a timestamp. VCS provides means to query the history of file which proved to be very efficient way of learning how and why software evolved in a particular way. Another aspect is regulatory constraints - almost every commercial software requires transparent history of the code. **Backup** Unfortunately, we make mistakes. If we think for a second about our fictitious setup when developers were using shared folder - what would happen when someone made a mistake which must have been rolled back (to undo the last change). In a shared folder scenario it would have been close to impossible. VCS on the other hand works as a database, documenting evolution of your code and enables you to "go back in time" and revert your code to the past state. ###How teams use VCSThe idea of VCS doesn't enforce one particular way of working. Each projects is different and it's team's responsibility to adopt a workflow which suits them best. VCSs have been around for quite some time and few workflows emerged as the most popular.**Centralized** In centralized workflow we have an official repository. It's goal is to provide one focal point from where all developers in the team take the latest code. Every developer subscribes to the official repository - creates a copy on their PC, makes changes locally and then pushes them to the official repository. Once these changes are in the official repository they become visible to all other developers.[PICTURE-CENTRALIZED-WORKFLOW] **Distributed** In centralized workflow we had only one repository to which developers subscribe. In distributed workflow we have many. It usually suits large projects with large number of contributors. Two workflows worth examining are the ones used by GitHub and Linux communities. In GitHub we usually have one official repository. Developers can fork it - create a copy of this repository (which is publically available) which belongs to this developer. They as well as other people can contribute to this forked repository (from their local copies which subscribe to them). Once their project is completed (eg development of a new feature) they can request the official repository to include their changes into the official code (it's usually called creating a pull request and it's often done via some integration repository in which others can validate that new changes are well integrated with the larger system). Picture below illustrates it. [PICTURE-GITHUB-WORKFLOW]Linux kernel is one of the largest projects and over time it developers its own workflow with lieutenants. Each lieutenant is responsible for integrating changes from a particular area of larger system, and later promoting them to dictator who has a final say what goes into the official repository. Below picture depicts this workflow. [PICTURE-LINUX-WORKFLOW]###Git approach Git in its nature is a distributed system, however, flexible enough so it can easily accommodate a centralized workflow too. In contrast to many other version control systems, like SVN or Perforce, when you subscribe to the remote repository Git creates a full-featured repository on your local PC. It's not just a copy of the current code, you actually get the entire history of all files. Another big different compare to other popular systems is that Git, because of how it's organized, encourages certain habits - frequent check-ins (committing your changes), and branching. We'll talk about branching more in the next section - this is a very useful feature, however, it is quite cumbersome to use in other systems. Git is also well suited for scripting - many teams wrote their own scripts sitting on top of Git. In fact it created a platform for few commercial applications. ## Git internals This section will explain how you can get started with Git. Then we will do few basic operations and dive right into the internals of Git - what is actually going on under the hood. ###Installing GitIn order to install Git go to     https://git-scm.com/and download the latest Git release. If you are installing it on Windows OS, at some point installation wizard will prompt you with the option to "Adjusting your PATH environment".  Select "Run Git and include Unix tools from the Windows Command Prompt" - there is a red warning next to it. It replaces Windows' find command (no-one uses it anyway) with its Unix version which is much more powerful, and adds few more commands, eg ls.###First steps Now we have Git installed on our machine, so let's create a new repository and make some changes to it. Next, we'll see what Git actually stores this information. First, let's navigate to the folder where we want to create a new repository (feel free to locate it elsewhere, it doesn't matter). In this tutorial we will be interacting with Git via command line.    $ cd c:\    $ mkdir git    $ cd git    $ mkdir test_repo    $ cd test_repo Let's create a new Git repository    $ git init Initially our folder was empty. This command created a hidden folder (.git) which tells Git that this folder (test_repo) is now a repository. .git folder is going to store all information relating to your repository - history of files, all versions, their descriptions and many more.Let's now create a file and commit it to our repository. For brevity we'll do everything in console.    $ echo aaa >> a.txtThis command prints "aaa" into a a.txt file. Now we want to commit this file to our repository (create the first snapshot). We can do it by running this one command (later we will show you a different way which gives you more control over what happens)    $ git add .    $ git commit -m "Initial commit - added a.txt"Let's make some more changes: let's update a.txt file and create a new one.    $ echo bbb >> a.txt    $ echo 123 >> b.txtLet's now add them to the repository    $ git add .    $ git commit -m "Updated a.txt and created b.txt"OK. Now it's a good time to look retrospectively what has just happened. In the previous section we said that Git (like any other version control system) records changes that happens to our software. In this repo we recorded 2 changes* First, when we created a.txt file with "aaa"* Second, when we updated a.txt by adding second line with "bbb" and created a new file, b.txt with "123"Git's job is to record them (on our request) and allow us to view this history. We can easily view this history by running the following command.    $ git log The output can look like this    commit d5a235c0af73676dabbf28d957090043492c98b1    Author: Karol Gornicki <karol.gornicki@gmail.com>    Date:   Sun Oct 23 20:14:30 2016 +0100        Updated a.txt and created b.txt    commit 814facd944926d714eae63a4f53fd9d430101b0e    Author: Karol Gornicki <karol.gornicki@gmail.com>    Date:   Sun Oct 23 20:13:49 2016 +0100        Initial commit - added a.txtThis shows journal of all changes that we made in our repository. As you can see the most recent change is listed at the top. As we can see, each commit has a unique ID (the 40-character long string next to the word commit). This is how Git identifies commits. In fact, when we ran     $ git commit [...]    Git creates a commit object which encapsulates all relevant information for that snapshot and stores it in .git folder. More about that in the next section.###Object-based databaseAll files related to the management process of our repository are stored in .git folder that was created when we ran $ git init command. Let's navigate to that folder and see what's in it     $ cd .git    $ ls -l    As we can see that are few folders in it. For the time being we will focus on objects folder and as we advance further in this tutorial we will come back here and talk about the remaining ones.    $ cd objects     $ ls -l    There are quite a few folders with names only 2-characters long. When Git creates objects it gives each object an ID (40 character long) and splits it into prefix and suffix 2+38 respectively. The prefix is used to create a folder and inside that folder it creates a file named using suffix. So if we look at our most recent commit its ID is d5a235c0af73676dabbf28d957090043492c98b1 and indeed we can see "d5" folder. If we enter that folder we can see a file which name's correspond to the last 38 characters of the ID.     $ cd d5    $ ls -l    If we try to open this file in any text editor we will find out that it's content is not readable. Git in order to preserve space on your drive compresses these files. Fortunately, we can use one of many git commands to read the content of that file, referning it by the ID.    $ git cat-file -p d5a235c0af73676dabbf28d957090043492c98b1    The output    tree 40605725a8fef247117f96546f88e139365849a8    parent 814facd944926d714eae63a4f53fd9d430101b0e    author Karol Gornicki <karol.gornicki@gmail.com> 1477250070 +0100    committer Karol Gornicki <karol.gornicki@gmail.com> 1477250070 +0100    Updated a.txt and created b.txt    At the very bottom we can see the description that we gave to that commit when we created it. It also has an information about committer and author. Lastly we see 2 entries, parent and tree. However, they are  different than all other entries. Instead of having any infromation they reference other files (by their IDs). If we look carefully we notice that the 40-character long ID next to parent is exactly the same as ID of the first commit. This tells Git what was the previous state (the previous commit) of our files. Every commit (except from the first commit) has at least one parent. We'll talk later when a commit can have multiple parents. To visually represent this notion you can think that each commit has a pointer to their parent commit - the one that happen before. This creates a directed graph.[PICTURE-2-COMMITS]The last thing that must discuss here is tree entry. This entry points to the state of our files. So let's see what's in it. Git allows us to interrogate all of its files, so we can use exactly the same command to inspects its content.    $ git cat-file -p 40605725a8fef247117f96546f88e139365849a8    The output is     100644 blob d2260f8cf9979e1d457aa040b73f61244a902d82    a.txt    100644 blob fb0a03d992212388b6835ab96fe4affa483a100b    b.txt    It depicts how our repository looked like when we made a commit. At that time we had 2 files, and they both are represented by Git objects. If we drill down to any of them we'll see their content at that time.     $ git cat-file -p d2260f8cf9979e1d457aa040b73f61244a902d82Git stores the entire content of that file (at the time of the snapshot), not just changes that we've made. Git is very space efficient in doing so and there is no need to be worried. To the left of the ID we have "blob". This is type of the file. If we would have a folder in our directory it would be represented by a file of a type "tree". Drilling down into this file would reveal its content, just like we've done it here. The picture below visualizes how our repository could be represented.[PICTURE-GIT-COMMITS-AND-FILES]During the evolution of your repository Git simply grows its files representing various objects. This is essentially Git's database storing history of everything that happened in your repo. Let's come back to the root folder of our repository.    $ cd ..\..\..    ### References and branches Previous section explained how Git stores all the information about commits. During the inspection we learned that commits point to their parent commits (ones that happened immediately before). Therefore Git must knows which commit is the last one. Indeed, when we run log command it shows the most recent commit at the top. Git stores the reference to the most recent commit and it is called HEAD. Not surprisingly, HEAD is a file in .git folder. We can inspect its content.    $ type .git\HEAD    It prints     ref: refs/heads/masterIt simply represents a reference to another file. If we navigate to that file and open it up we'll find that this file contains only 40-character long ID (of the last commit).    $ type .git\refs\heads\master     It prints     d5a235c0af73676dabbf28d957090043492c98b1    which is ID of the last commit. Let's create another commit to see what happens.    $ echo ccc >> a.txt    $ git add .    $ git commit -m "Added ccc to a.txt"    master file was updated and now it points to the most recent commit. We can also see it using --decorate option for log command.    $ git log --oneline --decorate     It shows    da9e20e (HEAD -> master) Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txtBy default log command is quite verbose and for brevity we used here additional parameters. --oneline presents log in abbreviated format, and --decorate includes information about references. In this case it shows that the last commit is marked as HEAD, and HEAD is pointing to master. Master is not some random file. It's a branch. Every Git repository is created, by default, with a single branch called master. As you can see from the above, branch is just a pointer to the commit. We can see all branches in our repository by running     $ git branch     It shows     * master    We only have one branch, * next to the name of the branch indicates our currently checked out branch. Let's create a new branch then. We can do it by running     $ git branch experiment     If we re-run branch command we get       experiment    * master    Now we've got 2 branches. Since branches are just stored in files, we can inspect them.    $ cd .git/refs/heads/    $ ls -l    $ type experiment     $ type master     Both of them point to the same commit. We can also see it reflect in log.    $ cd ..\..\..    $ git log --oneline --decorate     Prints:    da9e20e (HEAD -> master, experiment) Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txtGit encourages developers to work on branches, where each branch represents a stream of work - for example a development of a new feature, or a bug fix. First let's see it in practice. Let's first check out branch - it tells Git on which branch we want to work now.    $ git checkout experiement     We can also inspect quickly how HEAD look now.     $ type .git\HEAD    HEAD is now poitning to experiment, whereas it was previously pointing to master. Let's make some changes to our files and commit them     $ echo ddd >> a.txt    $ git add .     $ git commit -m "Added ddd to a.txt"    Let's see how it is reflected in log.    $ git log --oneline --decorate     It prints     5539dc6 (HEAD -> experiment) Added ddd to a.txt    da9e20e (master) Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txtWhat's interesting is that we created a new commit (listed at the top), and experiment branch is pointing to it. However, master branch "didn't move". It points to the third commit as it was before. That's because we checked out to experiment branch, which essentially told Git that now we are working on this branch and any commits should be commited to this branch. If we inspect the content of the last commit we will learn that it references 3rd commit as its parent.     $ git cat-file -p 5539dc6    It prints     tree 966f4a6af5210044f777610113d9aaf454eed377    parent da9e20ee64755bb5b705c277599db88466903d0e    author Karol Gornicki <karol.gornicki@gmail.com> 1477250610 +0100    committer Karol Gornicki <karol.gornicki@gmail.com> 1477250610 +0100    Added ddd to a.txtOur repository can be depicted as a graph [PICTURE-REPO-GRAPH]In the next section we will show how we can join branches (Git calls it merging), but before that we have to revisit the checkout command. We said that it tells Git on which branch we want to work (it updates HEAD file to point to the branch selected by us). Obviously we can have more than one branch, so what exactly happens when we switch branches. Let's to the experiement. At first, let's print the content of a.txt (tail prints the last 10 lines of a file).        $ type a.txt    We can see all 4 lines. Let's now switch to master and inspect the same file.    $ git checkout master     $ type a.txt    It doesn't have the last line - "ddd". This goes back to the point when we talked about commit objects - they store full content of all files in our repo. When we checkout a branch (and remember, branch is just a pointer to a commit object) Git updates all files to the state as of that commit. If we now run log command     $ git log --oneline --decorate     we will see only 3 commits - branch master doesn't know about branch experiment, and it shouldn't. da9e20e commit only has a pointer to its parent (previous) commit, not the future ones.In the next section we'll explain how you can work productively with Git and cover more complicated scenarios.    ## Working with Git (locally)In this section we would like to explain in more detail how you can work with Git. We will take case study apprach - each demonstrating different problem and how it can be addressed using Git. ### Branches and mergingIn the previous section we explained how branches work. Branch is just a pointer to the commit object - nothing more. Because of that creating branches is cheap and quick. In fact, while working with Git you are going to use them - a lot! Most repositories are organized in a way that master branch represents code that is stable and was released. If you want to create new features you create a branch. On that branch you develop your new feature. Once you are happy with your new code and everything is tested you integrate your change to the master branch. And this is our first use-case - we are going to create a new branch, add something to it and finally integrate our new stuff with main development stream (master branch).#### Use Case #1 - Fast forwardLet's start by switching to master and creating a new branch     $ git checkout master     $ git branch feature/1    Let's checkout feature/1 branch     $ git checkout feature/1     In order to simulate development of a new feature let's add a new line to a.txt.    $ echo xxx >> a.txt    And let's commit this change         $ git add .    $ git commit -m "Added feature 1"    Quick look on log of our repository     $ git log --oneline --decorate     Our repository can be depicted as [PICTURE-REPOSITORY]Let's have a log at the output printout (later we will compare with after the merge).    $ git log --oneline --decorate     It prints     140c07a (HEAD -> feature/1) Added feature 1    da9e20e (master) Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txtNow, we would like to integrate our feature/1 changes into the master branch. This process is called merging in Git. We are going to merge feature/1 into master. In order to od that, we first have to switch to our master branch (because we want to intergrate changes from feature/1 into master).    $ git checkout master     And now we want to request to merge feature/1 into master     $ git merge feature/1    The output of this command is:    Updating da9e20e..140c07a    Fast-forward     a.txt | 1 +     1 file changed, 1 insertion(+)    First we have yo understand how Git is merging. This is how Git appraches a merge scenario. Git looks at the 2 branches - each pointing to a commit. In our case master points to da9e20e and feature/1 points to 140c07a. Since our commit history is essentially a graph (as we have seen earlier) Git finds the first common ancestor for both commits. In this case the first common ancestor for the 2 commits is da9e20e. This clearly says to Git that there was no development on master since we created a new branch and in order to incorporate changes from feature/1 branch all it has to do is update master branch pointer to point to 140c07a. This operation is called fast-forward, and it's exactly what Git reports in the printout after we run merge command. After running this command our repository is depicted below. [PICTURE-REPO-AFTER-MERGE]Now we can delete feature/1 branch (which means that we are going to delete a pointer to the last commit) because it master and feature/1 are now pointing to the same object.Before we finish this use case let's look at the log printout        $ git log --oneline --decorate     which prints     140c07a (HEAD -> master, feature/1) Added feature 1    da9e20e Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txt    We can compare with the previous printout (before the merge) and we can see that all commit objects have the same IDs (which means they were not changed) and only the master branch (pointer) was updated. Finally, we can clean up unnecessary branches        $ git branch -d feature/1#### Use Case #2 - 3-way merge In the first use case we saw a very simple scenario - we created a branch, developed a new feature on it and then brought this change into master while nothing new was added to the master in the meantime. Let's now simulate a more realistic scenario - we are going to develop a new feature but before we bring our changes into the master we update master branch we a new commit (in order to simulate that as we were developing our new feature other member of a team committed their updated while we were working on ours).Let's start with creating a new branch of our dev work.    $ git checkout master     $ git branch feature/2     $ git checkout feature/2     The same as before let's simulate our work by adding a new line to our a.txt file    $ echo yyy >> a.txt     $ git add .    $ git commit -m "Added feature 2"    Now let's quickly checkout back to master, and create a commit which will simulate work done by someone else.     $ git checkout master     $ echo +++ >> b.txt     $ git add .     $ git commit -m "Added feature 3"    Right. Now let's bring out changes from feature/2 branch into master. We are already on master branch so let's run a merge command and see what happens.     $ git merge feature/2    Git prints        Merge made by the 'recursive' strategy.     a.txt | 1 +     1 file changed, 1 insertion(+)    In this instance Git applied recursive strategy. It starts similarly to the previous case - Git first looks for the first common ancestor. In this case none of our two branches is poinitng to this commit so Git cannot just update master pointer - this way it would have lost feature/3 commit. What Git does in this case it inspects changes made to both sequence of commits (streams of work) since the first common ancestor and looks for conflicts. BY conflict we understand that the same line of code was updated in 2 streams (branches). If there are no conflicting changes Git can automatically merge changes. We will look more closely at conflict resolution in the next use case. Since here we were making changes to 2 different files there was no conflicts and Git handled the entire situation for us. Let's look at the log printout    $ git log --oneline --decorate     Which prints     c41a863 (HEAD -> master) Merge branch 'feature/2'    40dc13c Added feature 3    bd24479 (feature/2) Added feature 2    140c07a Added feature 1    da9e20e Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txtWe can immediatelly spot that Git created a new commit and called it     Merge branch 'feature/2'    Actually, we can get a better intuiton what exactly happened by inspecting a graphical representation of the log. We can do it in console by running log command with --graph paramter.    $ git log --oneline --decorate --graph     Which prints     *   c41a863 (HEAD -> master) Merge branch 'feature/2'    |\    | * bd24479 (feature/2) Added feature 2    * | 40dc13c Added feature 3    |/    * 140c07a Added feature 1    * da9e20e Added ccc to a.txt    * d5a235c Updated a.txt and created b.txt    * 814facd Initial commit - added a.txt    Now we can clearly see that our new commit has 2 parents. The same information can be found in object itself.    $ git cat-file -p c41a863    It prints     tree 3dedb7b88d4c227403ee66e9f513b9aa12a07736    parent 40dc13c79df698f8eaf437387e5c38ed72bb7cc4    parent bd24479a7b82df28825babcc30effe08bc2dd41f    author Karol Gornicki <karol.gornicki@gmail.com> 1477251081 +0100    committer Karol Gornicki <karol.gornicki@gmail.com> 1477251081 +0100    Merge branch 'feature/2'    Before we close this use case let's clean up unnecessary branches:    $ git branch -d feature/2     #### Use Case #3 - 3-way merge with conflicts In this use case let's recreate previous scenario - we create a new branch, make some changes and commit them. At the same time we create a new commit on master. However, this time we are going to create a conflicting change - in both commits we are going to update the same line. We will see how Git is handling it, and how we can improve the process (which will lead us to Use Case #4).So, let's get started.    $ git checkout master     $ git branch feature/4     $ git checkout feature/4    $ echo zzz >> a.txt    $ git add .     $ git commit -m "Added feature 4"    Now let's checkout to master and add different last line to a.txt     $ git checkout master    $ echo @@@ >> a.txt     $ git add .     $ git commit -m "Added feature 5"     Now let's merge 2 branches together.     $ git merge feature/4    Git prompts us with the following message     Auto-merging a.txt    CONFLICT (content): Merge conflict in a.txt    Automatic merge failed; fix conflicts and then commit the result.Git attempted to do the merge, it discovered conflicts which means it couldn't figure out which changes should be applied to the final version and requested your assistance to fix them before making the final commit. You can see what are the conflicts by running a status command.     $ git status    It printed out     On branch master    You have unmerged paths.      (fix conflicts and run "git commit")      (use "git merge --abort" to abort the merge)    Unmerged paths:      (use "git add <file>..." to mark resolution)            both modified:   a.txt    no changes added to commit (use "git add" and/or "git commit -a")In this instance Git marked in the file areas of conflict and we have to resolve them manually. To see how a.txt looks after running this command.    $ type a.txt     Which prints     aaa    bbb    ccc    ddd    xxx    yyy    <<<<<<< HEAD    @@@    =======    zzz    >>>>>>> feature/4    To see in colors what the changes are we can run diff command (we'll talk about those commands in more detail in upcoming sections)     $ git diff a.txt    Which prints     diff --cc a.txt    index 01cc485,2c97fe7..0000000    --- a/a.txt    +++ b/a.txt    @@@ -3,4 -3,4 +3,8 @@@ bb      ccc      xxx      yyy    ++<<<<<<< HEAD     +@@@    ++=======    + zzz    ++>>>>>>> feature/4Notice the indention of + signs - this actually indicated from which branch change was brought.     We can see that HEAD (which is a commit Added feature/5 from master has @@@ whereas feature/4 added zzz. It's now our job to remove Git annotations: <<<< ===== >>>>. Let's say we want to make the last line @zz. We have to open a.txt in a text edior of our choice and make necessary changes. We can use Vim or notepad.    $ vim a.txt    $ notepad a.txt     Now we can inspect our change one more time using diff command     $ git diff a.txt     This time it prints     diff --cc a.txt    index c2a946f,3811863..0000000    --- a/a.txt    +++ b/a.txt    @@@ -4,4 -4,4 +4,4 @@@ cc      ddd      xxx      yyy    - @@@     -zzz    ++@zzNow all we have to do it to commit this change. We will do it in the exact same way as before, and later we'll talk in more detail about add and commit commands.    $ git add .    $ git commit -m "Merged feature 4 into master"    Quick look at the log    $ git log --oneline --decorate --graph     It prints     *   f6acb1c (HEAD -> master) Merged feature 4 into master    |\    | * b7a0577 (feature/4) Added feature 4    * | 33254a6 Added feature 5    |/    *   c41a863 Merge branch 'feature/2'    |\    | * bd24479 Added feature 2    * | 40dc13c Added feature 3    |/    * 140c07a Added feature 1    * da9e20e Added ccc to a.txt    * d5a235c Updated a.txt and created b.txt    * 814facd Initial commit - added a.txtThis time intentionally we won't delete feature/4 branch as we're going to reuse it in the next use case.         #### Use Case #3 Analysis - Merging with conflicts analysis In the last two use cases we just saw how Git can handle marging branches. When everything is simple there is no challenge and git does everything automatically. However, when there are some conflicting changes (which is quite common in typical dev work) Git requires our assistance to reconcile differences. This poses another problem. We are making commits which resolve conflicts directly on to the master branch. If we are working only localy there is no harm in doing so. However, if we are merging on a server (we will talk about it later in the course) this can be problematic. Git has a solution for it, called rebasing. If we look once again on the graph representing our repository     $ git log --oneline --decorate --graph     We can see     *   f6acb1c (HEAD -> master) Merged feature 4 into master    |\    | * b7a0577 (feature/4) Added feature 4    * | 33254a6 Added feature 5    |/    *   c41a863 Merge branch 'feature/2'    |\    | * bd24479 Added feature 2    * | 40dc13c Added feature 3    |/    * 140c07a Added feature 1    * da9e20e Added ccc to a.txt    * d5a235c Updated a.txt and created b.txt    * 814facd Initial commit - added a.txtthat both changes: feature 4 and feature 5 are happening in parallel. At least when we look at branches. However the truth is that one of them happened before the other. To be more precise, feature/5 was added to the master branch before we integrated feature/4. And Git has a solution to this exact situation - it's called rebasing.As you can see feature 4 commit (b7a0577) and feature 5 (33254a6) share the same parent commit. This formation looks kind of like a fork - 2 commits have the sme parent. Git can sort of move this fork to happen after feature 5. In other words is can take our feature 4 branch and apply it after feature 5 branch. Let's see how it looks in practice. For brevity, let's undo the last commit     $ git reset HEAD~    $ git checkout -- a.txt     Later we explain how to undo commits in more detail. Now we want to re-apply our branch after the last commit on master branch. To do that we have to checkout feature/4 branch and call rebase command.     $ git checkout feature/4    $ git rebase master     This prints     First, rewinding head to replay your work on top of it...    Applying: Added feature/4    Using index info to reconstruct a base tree...    M       a.txt    .git/rebase-apply/patch:9: trailing whitespace.    zzz    warning: 1 line adds whitespace errors.    Falling back to patching base and 3-way merge...    Auto-merging a.txt    CONFLICT (content): Merge conflict in a.txt    error: Failed to merge in the changes.    Patch failed at 0001 Added feature/4    The copy of the patch that failed is found in: .git/rebase-apply/patch    When you have resolved this problem, run "git rebase --continue".    If you prefer to skip this patch, run "git rebase --skip" instead.    To check out the original branch and stop rebasing, run "git rebase --abort".Git essentially says that it tried to re-apply this change and encounter a conflict. It cannot resolve this conflict automatically, so we have to do it manually. This is pretty much exactly the same situation as before. To see which files require resolving    $ git status     We can look at the file     $ type a.txt     It looks exactly the same before, so we resolve the conflict in a text editor. After we resolved the conflict we have to add this file to the staging area (we will explain that in the next segment) and enter a command telling Git to continue rebasing.     $ git add .    $ git rebase --continue     It prints     Applying: Added feature/4    Because there are no more comments we know that Git finished rebasing. We can look at the graphical representation of our repository     $ git log --oneline --decorate --graph    It prints     * dcee90e (HEAD -> feature/4) Added feature 4    * 33254a6 (master) Added feature 5    *   c41a863 Merge branch 'feature/2'    |\    | * bd24479 Added feature 2    * | 40dc13c Added feature 3    |/    * 140c07a Added feature 1    * da9e20e Added ccc to a.txt    * d5a235c Updated a.txt and created b.txt    * 814facd Initial commit - added a.txtAs we can see this applies our feature 4 change after feature 5. In decorations of each commit we can see that feature 4 is applied of the last commit from master branch. In this situation if we would like to integrate these changes into master we simply run merge command which would perform fast forward. Fast forward simply updated master branch ponter.We can also notice that Git didn't move the old commit ahead of all other commits, it re-created that commit (+ any changes that resulted with rebasing). We can inspect this change by        $ git show dcee90eWhy does it matter? Using this apprach is preferred when we work with a remote repository. The same way as we here integrate our changes with master branch we can push our changes to some remote repository and integrate with its master branch. We would like to resolve all possible conflicts in our local repository and only when we are sure that everything works we would push our changes and on the server, in order to bring those changes into master we Git would only do fast-forward merge. Resolving conflicts is error prone. It is simply better to do it privately and only when we are sure we promote it to the master branch. Also, our history is clearer. let's finish the job by merging them        $ git checkout master    $ git merge feature/4     And look at the log     $ git log --oneline --decorate --graph     It prints     * dcee90e (HEAD -> master, feature/4) Added feature 4    * 33254a6 Added feature 5    *   c41a863 Merge branch 'feature/2'    |\    | * bd24479 Added feature 2    * | 40dc13c Added feature 3    |/    * 140c07a Added feature 1    * da9e20e Added ccc to a.txt    * d5a235c Updated a.txt and created b.txt    * 814facd Initial commit - added a.txtWe don't have a merge commit, and instead resolving any conflicts happened in feature 4 commit (dcee90e). This will be beneficial in the future when you will have to inspect the history of changes in order to understand what has changed and when. ### Three statesLet's talk now how Git organizes a working directory. When we create a new repository with     $ git init     Git treats that folder as a Git repository. It allows you to commit changes made to files in that folder and whatnot. In earlier parts of this tutorial we didn't pay much attention to this as we were focusing on internal mechanics of Git. In this section however we are going to explain in detail what is going on in your workspace - often refered to as working directory. Let's get right into the demo and make a change to one of our files     echo new line ... >> a.txt     echo another new line ... >> b.txt    Our file has changed, we appended a new line. Git allows us to discover any files that were changed or, were added.     $ git status     The output of this command    On branch master    Changes not staged for commit:      (use "git add <file>..." to update what will be committed)      (use "git checkout -- <file>..." to discard changes in working directory)            modified:   a.txt            modified:   b.txt    no changes added to commit (use "git add" and/or "git commit -a")tells us on what branch we are currently working, and lists all files that were either edited, added or removed since the last commit. Previously in order to commit our changes we were running the following commands (don't run the below commands now).    $ git add .    $ git commmit -m "Here we were adding a message"     If you did run them you can undo it by     $ git reser HEAD~    Let's break it down, line by line. The first line calls add command. This command adds selected files to staging area - dot (.) means add everything. Staging area is the area where we prepare our commit - in our working directory we can change bunch of files but we only want to commit some of them. Let's say we only want to commit file a.txt.     $ git add a.txt     If we now check the status of out repository    $ git status    it prints     On branch master    Changes to be committed:      (use "git reset HEAD <file>..." to unstage)            modified:   a.txt    Changes not staged for commit:      (use "git add <file>..." to update what will be committed)      (use "git checkout -- <file>..." to discard changes in working directory)            modified:   b.txtIt shows  that file a is marked as "to be committed" - that's the staging area (also called index) where we are preparing the commit, whereas b.txt is listed under not staged. Now we could commit only a.txt but before we do that let's talk about diff command. Just because we made a change to a.txt and added it to staging it doesn't prevent us from adding another change.     $ echo another line ... >> a.txt     If we run status command     $ git status     we get     On branch master    Changes to be committed:      (use "git reset HEAD <file>..." to unstage)            modified:   a.txt    Changes not staged for commit:      (use "git add <file>..." to update what will be committed)      (use "git checkout -- <file>..." to discard changes in working directory)            modified:   a.txt            modified:   b.txtOn the first instance that may look weird that a.txt appears in both categories, but it actually makes sense. First we added a line and added this to staging area. We didn't actually added a file - we added our change. So if we make another change Git simply interprets it as another change that we have to add.Working directory can be depicted like that [GIT-WORKING-DIRECTORY]These are the three states: working directory, staging, and repository.Just knowing which files has change is only parlty useful - we would like to know what exactly did we change and we are about to commit. To discover this information we are going to use diff command (we used it briefly earlier on). This command allows us to see differences between files in different states.To see what we changed in b.txt simply run     $ git diff b.txt    In order to see all changes that we introduced since the last commit to file a.txt run     $ git diff HEAD a.txt     This lists 2 new lines. In order to see what we added to staging (for a.txt) run        $ git diff --staged a.txt     In order to see unstaged changes to a.txt run     $ git diff a.txt     This can be represented on a chart as [CHART-DIFF-STAGES]Now you also understand when we were rebasing and had to resolve conflicts we were adding resolved files to staging area and entering a command for Git to continue rebasing. Git was essentially picking up files from staging area in order to make a new commit. Remember, during rebasing Git doesn't move commits, but it actually creates a completely new ones (only changes made to files are the same + your conflict resolutions). ### UndoOne more thing before we conclude this section. Say we did something wrong and we want to undo our changes. In order to take a file out of staging area run     $ git reset a.txt     In order to remove all changes we made to the file        $ git checkout -- b.txt    In order to undo the entire commit let's first add a new one.    $ git add a.txt     $ git commit -m "Updated a.txt with 2 extra lines" Quick look at logs    $ git log --oneline     In order to remove this commit run     $ git reset HEAD~    $ git log --oneline     Our commit it gone, if we look at the status     $ git status We can see that there are some uncommitted changes to a.txt. If we drill down    $ git diff a.txt We can see that Git removed the previous commit (in fact the object is kept in .git folder - go to .git folder and try to find this object) but kept all the changes that we previously made in case we wanted to make some quick fix. If you want to discard there changes simply run    $ git checkout -- a.txt     ### PatchingAs we saw previously, in Git you can add only some of your changes made to the file to staging area. Let's now update first and last line of a.txt - for readability we will use numbers. Updated file looks like that     $ type a.txt    And Git diff        $ git diff a.txt     prints     diff --git a/a.txt b/a.txt    index b741796..3fc402d 100644    --- a/a.txt    +++ b/a.txt    @@ -1,7 +1,7 @@    -aaa    +123     bbb     ccc     ddd     xxx     yyy    -@zz    +987    Say we only want to commit the first line change, but not the last one. Git allows us to do it by patching. We will tell Git to break changes to this file into chunks (Git calls them hunks - don't know why). This is a bit complicated, but turns out to be very useful. We are going to use interactive add command.     $ git add -i     This will prompt you with a menu, select p or 5. Next Git will list all files you can select a.Next hit Ctrl+Z and enter - this shows the first hunk. Git decided to treat our entire change as one hunk, however, we can break it into pieces. It prints     diff --git a/a.txt b/a.txt    index b741796..3fc402d 100644    --- a/a.txt    +++ b/a.txt    @@ -1,7 +1,7 @@    -aaa    +123     bbb     ccc     ddd     xxx     yyy    -@zz    +987    Stage this hunk [y,n,q,a,d,/,s,e,?]?    it gives us quite a few options, type ? to see their explainations. We want to select e (for edit). It opens Vim with     # Manual hunk edit mode -- see bottom for a quick guide    @@ -1,7 +1,7 @@    -aaa    +123     bbb     ccc     ddd     xxx     yyy    -@zz    +987    # ---    # To remove '-' lines, make them ' ' lines (context).    # To remove '+' lines, delete them.    # Lines starting with # will be removed.    #    # If the patch applies cleanly, the edited hunk will immediately be    # marked for staging. If it does not apply cleanly, you will be given    # an opportunity to edit again. If all lines of the hunk are removed,    # then the edit is aborted and the hunk is left unchanged.    In order to keep the first line update @@ -1,7 +1,7 @@ to be @@ -1 +1 @@ and remove the last two lines. The file should look like that. In Vim in order to edit you have to enter interactive mode (hit i) - now you can edit as you would do in notepad or any other text editor (you cannot use mouse though).    # Manual hunk edit mode -- see bottom for a quick guide    @@ -1 +1 @@    -aaa    +123     bbb     ccc     ddd     xxx     yyy    # ---    # To remove '-' lines, make them ' ' lines (context).    # To remove '+' lines, delete them.    # Lines starting with # will be removed.    #    # If the patch applies cleanly, the edited hunk will immediately be    # marked for staging. If it does not apply cleanly, you will be given    # an opportunity to edit again. If all lines of the hunk are removed,    # then the edit is aborted and the hunk is left unchanged.Save your changes and quit Vim (ESC + :wq + ENTER). Quit interactive add command with q + ENTER. Now let's see how our status look like     $ git status     All good. We can inspect changes        $ git diff --cached a.txt     $ git diff a.txt This technique is particulary useful when we mock about with config or solution files.## Working with Git (remotely)In the previous segment we discussed various use cases how you can work with Git. However, software development in usually a team effort and you will have to collaborate with others. And this is where working remotely comes at play. In this part of the tutorial we will discuss various aspects of it - starting from how to copy a remote repository, how to send changes and conclude with some management tips. ### Copying a remote repository. In this tutorial thus far we were exploring Git using our local reposotory. We can get the path to our repository by running pwd - print working directory command.     $ pwd Let's create a copy of this repository, but first go the the folder where we want to create our copy. We create a copy (clone) of the repository by referencing its .git folder. The last parameter in clone command is how the new folder is going to be named.     $ cd c:\git     $ git clone c:\git\test_repo\.git test_repo_clone    $ ls -l     We can see that a new folder was created, and if we inspect its content we will notice that it looks pretty much the same as our original repository. Git created a clone of our original repository - that means we not just have all the files but we also have their entire history and such. This is now a fully functioning repository. In fact, Git did a little more than just that. Besides copying all the files Git also created links (called references) to the original repository from which it cloned all the files.     $ cd test_repo_clone    $ git status     It prints     On branch master    Your branch is up-to-date with 'origin/master'.    nothing to commit, working tree cleanIt reports that out current master branch is up-tp-date with 'origin/master'. This is how git references branches on a remote repository - remote repository is referred to as origin. As origin of this repository. In other words we have a master branch in our local repository which is linked to master branch in a remote repository (the one we copied from) - and they both point to a commit object with the same ID. We could also say that they are in sync. Git allows you to see your local branches by running     $ git branch     which prints     * master    And all remote branches     $ git branch -r     which prints       origin/HEAD -> origin/master      origin/experiment      origin/feature/4      origin/master    In the next section we will explain how you can receive updated from remote repository.### Receive updates OK, now we'ge got our copy of remote repository. The idea of connecting to remote repository is that we take updates from it, or send updates. Let's first see how we can get any updates. To do that, let's switch to the original repository and make some change and see what happens.     $ cd ..    $ cd test_repo    $ echo *** >> a.txt    $ git commit -am "Added *** to a.txt"    Commit command with -am parameter is a shortcut for add all and commit with message. Quick look at the log        $ git log --oneline    which prints     729be61 Added *** to a.txt    dcee90e Added feature 4    33254a6 Added feature 5    c41a863 Merge branch 'feature/2'    40dc13c Added feature 3    bd24479 Added feature 2    140c07a Added feature 1    da9e20e Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txt    Let's now switch back to cloned repo and see how things looks there.     $ cd ..    $ cd test_repo_clone    $ git status     No change here - it says we are up to date. So let's inspect the log     $ git log --oneline     It prints     dcee90e Added feature 4    33254a6 Added feature 5    c41a863 Merge branch 'feature/2'    40dc13c Added feature 3    bd24479 Added feature 2    140c07a Added feature 1    da9e20e Added ccc to a.txt    d5a235c Updated a.txt and created b.tx    814facd Initial commit - added a.txt    Now this doesn't show the change that happened in the remote - why is that? The reason is - Git doesn't automatically take updates. And it's actually quite a good thing - imagine you are working on a new feature and all of a sudden someone made a change that conflicts with yours and you are asked all of a suddent to resolve a conflict. Instead you have to specifically ask Git to check if there was anything new added to the remote repository and bring those changes in. It happens in 2 steps * fetch updates * merge these updates into your files So, in order to get the latest updates we have to run fetch command     $ git fetch     It prints     remote: Counting objects: 4, done.    remote: Compressing objects: 100% (2/2), done.    remote: Total 4 (delta 0), reused 0 (delta 0)    Unpacking objects: 100% (4/4), done.    From c:\git\test_repo\       dcee90e..729be61  master     -> origin/masterIf we now run the status command     $ git status     We get     On branch master    Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.      (use "git pull" to update your local branch)    nothing to commit, working tree clean    What does that exactly mean? When we cloned original repository Git liked our master branch in this (cloned) repository to master branch on remote repository. This is called tracking - we would say that our master branch tracks master branch on remote repository. When we run branch -r command     $ git branch -r     We see that Git lists origin/master. So let's checkout this branch.     $ git checkout origin/master     It prints     Note: checking out 'origin/master'.    You are in 'detached HEAD' state. You can look around, make experimental    changes and commit them, and you can discard any commits you make in this    state without impacting any branches by performing another checkout.    If you want to create a new branch to retain commits you create, you may    do so (now or later) by using -b with the checkout command again. Example:      git checkout -b <new-branch-name>    HEAD is now at 729be61... Added *** to a.txt    It says that we are in detached HEAD state. We will explain what that means in a second (it's actually very important concept to understand) but first let's check log.    $ git log --oneline --decorate     This prints     729be61 (HEAD, origin/master, origin/HEAD) Added *** to a.txt    dcee90e (origin/feature/4, master) Added feature 4    33254a6 Added feature 5    c41a863 Merge branch 'feature/2'    40dc13c Added feature 3    bd24479 Added feature 2    140c07a Added feature 1    da9e20e Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txt    As you can see latest updates are there. So, when we run fetch command Git took updates from remote repository, created objects for them (they are stored in .git folder) and updated heads of remote branches to point on them. The only step left is to merge them with your local branches (updating your local branches to point to those new commit objects) - which is done with merging (or pull command which does these 2 things for you). Let's now exaplain what does detached HEAD mean. It happens when we run checkout command with either commit ID or remote branch. After executing this command HEAD pointer is being updated with ID of current commit object (and files in working directory are updated accordingly). However, this commit object is not being referenced by any branch in your repository (remote branch is like a point of reference to know at what state is our remote repository). Therefore if we would make any changes and commit them, this commit wouldn't be tracked by any branch. We could lose that commit the moment we would checkout a new branch - because none of other branches are pointing to that comit object. As message reads, we can create a branch on the fly and then we can commit our changes and be sure there is a reference to them. Coming back to our original thread - on order to get these changes integrated into our files (and updated local branches) we can run pull command - and this command is most commonly used. Pull command essentially combines 2 actions, fetching updated from original repository and merging them into your working directory.     $ git checkout master     $ git pull     $ git log --oneline --decorate    This prints     729be61 (HEAD -> master, origin/master, origin/HEAD) Added *** to a.txt    dcee90e (origin/feature/4) Added feature 4    33254a6 Added feature 5    c41a863 Merge branch 'feature/2'    40dc13c Added feature 3    bd24479 Added feature 2    140c07a Added feature 1    da9e20e Added ccc to a.txt    d5a235c Updated a.txt and created b.txt    814facd Initial commit - added a.txt    Now all looks good. If there would be any conflicting changes between your repository and updated pulled from the original you would have to resolve them in the same way as we have done earlier. Original repository can also add or delete branches - in order to update your remote references when you use pull command apply -p parameter (it will prune unnecessary references).    $ git pull -p     ### Adding and deleting branches remotelyLet's create a branch in our local repository. Next, let's export this branch to remote repository. First, let's see what branches we have     $ git branch Let's create a new branch     $ git branch new-name     This branch doesn't exist in the remote repository yet. We can export it by running push command - it basically promotes whatever we want to remote repoitory. Syntax is following     $ git push -u origin new-branch     -u parameter is a shortcut for upstream which will essentially make our local branch to track (link) the newly created branch on remote repository. This way other people can also update this branch and we will be able to fetch their updates too. The last two parameters set where and what we want to push - origin is how our remote repository is referred to in Git; new-branch is the branch we want to push. In order to delete a branch on remote run     $ git push origin :new-branch     Essentially prefix the name of your branch with a collon. This syntax says to Git push no data into that head on the remote repository. ### Sending changes to remote repositorySending change to the remote repository is as simple as running push command. So let's first make a new branch, promote it to the remote repository and commit something locally.    $ git branch new-branch     $ git push -u origin new-branch    $ git checkout new-branch     $ echo uuu >> a.txt     $ git commit -am "Added uuu to a.txt"     We just made a change locally. It's not visible on remote (feel free to check). In order to publish this commit to remote all we have to do is to run push command.        $ git push Note, that if we would have previously rebased this branch we would have to apply -f (for force) parameter in order to sucessfully execute push command.     $ git push -f It is usuallt the case that you are pushing something to the remote branch and create a pull request on the server. Next, person responsible for managing remote repository reviews your change and merges into main development stream (for example master branch) so everyone else can see this change and update their own repositories. 