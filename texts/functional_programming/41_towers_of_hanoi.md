#Towers of Hanoi (wishful thinking) In this series of essays we will demonstrate how to solve few problems in F#.Let’s start with a very simple problem called "Towers of Hanoi". You probably solved it in the past as it frequently features entry level programming modules. ##The problem We have 3 spikes and bunch of disks. Each disk has a unique diameter (so between the two we can always tell which one is larger). Initially, all disks are stacked on one spike, having largest disk at the bottom and the smallest at the top. The task is to move all disks to another spike. In doing so we have to adhere to 2 rules:* You can only move one disk at a time * You must not put larger disk on top of a smaller one##SolutionFirst we have to make sure that we understand the problem well. It’s usually a good practice to test how well we grasp the problem by solving it for some trivial input.So, let’s do just that. It’s trivial to move 1 disk, but how about 2? We start with ![PICTURE-1](https://github.com/karolgornicki/Articles/blob/master/img/functional_programming/hanoi_1.jpg)Let’s give names to our spikes, so we can easily refer to them: "from", "to", and "aux" (from auxiliary). Our goal is to move all disks to the "to" spike.![PICTURE-2](https://github.com/karolgornicki/Articles/blob/master/img/functional_programming/hanoi_2.jpg)To do that we have to first move the small disk to "aux" spike, next the large disk onto "to" and lastly move the small disk again, from "aux" to "to".![PICTURE-3](https://github.com/karolgornicki/Articles/blob/master/img/functional_programming/hanoi_3.jpg)That was pretty simple, however, for 3 and more disks it becomes a bit more challenging. Solving for small number of disks is pretty intuitive and we can come up with the solution pretty much right away, but for large number of disks we have to think carefully what strategy we must adopt. Moreover, it’s hard for most of us to envision long sequence of steps - how everything is going to unfold and be sure that everything is according to our plan. So, how would we write a program that solves this problem for us if we ourselves may find it hard to solve by hand? Usually we have some rules that we have to obey - constraints. We can usually start building from there. So what rules do we have?* We can move one disk at a time * We must not put large disk on top of a small oneThat’s actually very helpful. Let’s imagine a larger pile of disks, for instance 4, stacked on a single spike "from" and let’s observe those rules in action. At first, let’s move the top disk (the smallest one). We can freely choose whether it should go on spike "to" ot "aux". Let’s say we decided to move the smallest disk to "aux". Let’s move the next disk from spike "from". We can put it on "to" spike, but we can’t put it on "aux". Why? Because we would violate one of two rules - large disk can’t be stacked on top of a smaller one. OK, that’s interesting. Let’s expand on this and think for a second in which situation we would be able to move the largest disk sitting initally at the bottom of "from" spike. There’s only one scenario:![PICTURE-4](https://github.com/karolgornicki/Articles/blob/master/img/functional_programming/hanoi_4.jpg)"from" has only the largest disk, and all other disks resides on some other spike. Actually this is already enough for us to solve this problem. How? We can use technique we talked about earlier - wishful thinking. In the example we just saw there is one step we don’t know how to do - move all but last disk onto another spike. Let’s call function doing it move. Function must takes some input, so, we have to make a decision what arguments we are going to provide. We would like our function to give us a list of steps, say each step is a string "from -> aux" and similar. To do that we have to specify how many disks should be moved, from which spike, to where, and which spike can be used as a helper (auxiliary one). So, in order to implement our example (moving the largest disk) it becomes a pretty simple:At first we want to move (n - 1) disks (all but the last one) from "from" spike to "aux" spike.```fsharplet steps = move (n - 1) fromS auxS toS```This gives us a list of steps how to do that. Next, we want to add to that list our step in which we move the largest disk.```fsharplet stepsPlusLargeDisk =    steps    |> List.append [sprintf "%s -> %s" fromS toS]```List.append joins 2 lists together. Now, all we have to do is to move all remaining disks from "aux" spike to "to" spike and we’re done. And we can easily do it - move function does exactly that. So we can append this moves to the list that we already have.```fsharpList.append (move (n - 1) auxS toS fromS) stepsPlusLargeDisk ```We use (n - 1) because this is the number of disks we initially moved onto "aux" spike. OK, so the next task is to implement the move function. To do that let’s look at another example - how we would move 2nd largest disk. Again, there’s only one scenario in which it can happen.![PICTURE-5](https://github.com/karolgornicki/Articles/blob/master/img/functional_programming/hanoi_5.jpg)We would put the top disk from "fom" to "to" and then apply move function to move all small disks from "aux" to "to". Which gives us the setup for the scenario we first investigated. So, our move function can use itself. We’ve seen that before - that’s recursion. ![PICTURE-6](https://github.com/karolgornicki/Articles/blob/master/img/functional_programming/hanoi_6.jpg)In that case we can always call our function - always decrementing the first argument by 1 and selecting from which spike move disks to where (and which spike should be used as a helper). So, what we should do when our function is called with 0? We could simply return an empty lity - function returns list of steps, so if no step is required empty list seems appropriate. That’s pretty much all. Let’s put it all together in a single function ```fsharplet rec move n fromS toS auxS =    if n = 0    then []    else        let steps = move (n - 1) fromS auxS toS        let stepsPlus =            steps            |> List.append [sprintf "%s -> %s" fromS toS]        List.append (move (n - 1) auxS toS fromS) stepsPlus```If we call this function we will quickly realize that we always append elements at the beginning of a list - as a result, steps are presented in reverse order. That’s not a problem, we can at the end reverse the whole list. Let’s create another function for that```fsharplet hanoi n fromS toS auxS =    move n fromS toS auxS    |> List.rev```We can slightly improve our move function to remove all those unnecessary let expressions. ```fsharplet rec move n fromS toS auxS =    if n = 0    then []    else        move (n - 1) fromS auxS toS        |> List.append [sprintf "%s -> %s" fromS toS]        |> List.append (move (n - 1) auxS toS fromS)```If that was too easy, you can challenge yourself and try to come up with iterative algorithm, or, even better, running in parallel. Ralf Hinze from Oxford University wrote an interesting paper about it. [**LINK**](http://www.cs.ox.ac.uk/ralf.hinze/publications/ICFP09.pdf) (PDF file)Code for this puzzle can be found here: [**LINK**](https://github.com/karolgornicki/Articles/blob/master/src/hanoi.fsx)Next: [Largest Product (function composition)](42_largest_product.md)